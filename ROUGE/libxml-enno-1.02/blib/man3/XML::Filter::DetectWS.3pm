.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::Filter::DetectWS 3"
.TH XML::Filter::DetectWS 3 "2000-02-17" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::Filter::DetectWS \- A PerlSAX filter that detects ignorable whitespace
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use XML::Filter::DetectWS;
\&
\& my $detect = new XML::Filter::DetectWS (Handler => $handler,
\&                                         SkipIgnorableWS => 1);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This a PerlSAX filter that detects which character data contains 
ignorable whitespace and optionally filters it.
.PP
Note that this is just a first stab at the implementation and it may
change completely in the near future. Please provide feedback whether
you like it or not, so I know whether I should change it.
.PP
The \s-1XML\s0 spec defines ignorable whitespace as the character data found in elements
that were defined in an <!ELEMENT> declaration with a model of '\s-1EMPTY\s0' or
\&'Children' (Children is the rule that does not contain '#PCDATA'.)
.PP
In addition, XML::Filter::DetectWS allows the user to define other whitespace to 
be \fIignorable\fR. The ignorable whitespace is passed to the PerlSAX Handler with
the \fBignorable_whitespace\fR handler, provided that the Handler implements this 
method. (Otherwise it is passed to the characters handler.)
If the \fBSkipIgnorableWS\fR is set, the ignorable whitespace is simply
discarded.
.PP
XML::Filter::DetectWS also takes xml:space attributes into account. See below
for details.
.PP
\&\s-1CDATA\s0 sections are passed in the standard PerlSAX way (i.e. with surrounding
start_cdata and end_cdata events), unless the Handler does not implement these
methods. In that case, the \s-1CDATA\s0 section is simply passed to the characters 
method.
.SH "Constructor Options"
.IX Header "Constructor Options"
.IP "\(bu" 4
SkipIgnorableWS (Default: 0)
.Sp
When set, detected ignorable whitespace is discarded.
.IP "\(bu" 4
Handler
.Sp
The PerlSAX handler (or filter) that will receive the PerlSAX events from this 
filter.
.SH "Current Implementation"
.IX Header "Current Implementation"
When determining which whitespace is ignorable, it first looks at the
xml:space attribute of the parent element node (and its ancestors.) 
If the attribute value is \*(L"preserve\*(R", then it is *NOT* ignorable.
(If someone took the trouble of adding xml:space=\*(L"preserve\*(R", then that is
the final answer...)
.PP
If xml:space=\*(L"default\*(R", then we look at the <!ELEMENT> definition of the parent
element. If the model is '\s-1EMPTY\s0' or follows the 'Children' rule (i.e. does not
contain '#PCDATA') then we know that the whitespace is ignorable.
Otherwise we need input from the user somehow.
.PP
The idea is that the \s-1API\s0 of DetectWS will be extended, so that you can
specify/override e.g. which elements should behave as if xml:space=\*(L"preserve\*(R" 
were set, and/or which elements should behave as if the <!ELEMENT> model was
defined a certain way, etc.
.PP
Please send feedback!
.PP
The current implementation also detects whitespace after an element-start tag,
whitespace before an element-end tag. 
It also detects whitespace before an element-start and after an element-end tag
and before or after comments, processing instruction, cdata sections etc.,
but this needs to be reimplemented.
In either case, the detected whitespace is split off into its own PerlSAX
characters event and an extra property 'Loc' is added. It can have 4 possible
values:
.IP "\(bu" 4
1 (\s-1WS_START\s0) \- whitespace immediately after element-start tag
.IP "\(bu" 4
2 (\s-1WS_END\s0) \- whitespace just before element-end tag
.IP "\(bu" 4
3 (\s-1WS_ONLY\s0) \- both \s-1WS_START\s0 and \s-1WS_END,\s0 i.e. it's the only text found between the start and end tag and it's all whitespace
.IP "\(bu" 4
0 (\s-1WS_INTER\s0) \- none of the above, probably before an element-start tag,
after an element-end tag, or before or after a comment, \s-1PI,\s0 cdata section etc.
.PP
Note that \s-1WS_INTER\s0 may not be that useful, so this may change.
.SH "xml:space attribute"
.IX Header "xml:space attribute"
The \s-1XML\s0 spec states that: A special attribute
named xml:space may be attached to an element
to signal an intention that in that element,
white space should be preserved by applications.
In valid documents, this attribute, like any other, must be 
declared if it is used.
When declared, it must be given as an 
enumerated type whose only
possible values are \*(L"default\*(R" and \*(L"preserve\*(R".
For example:
.PP
.Vb 1
\& <!ATTLIST poem   xml:space (default|preserve) \*(Aqpreserve\*(Aq>
.Ve
.PP
The value \*(L"default\*(R" signals that applications'
default white-space processing modes are acceptable for this element; the
value \*(L"preserve\*(R" indicates the intent that applications preserve
all the white space.
This declared intent is considered to apply to all elements within the content
of the element where it is specified, unless overriden with another instance
of the xml:space attribute.
.PP
The root element of any document
is considered to have signaled no intentions as regards application space
handling, unless it provides a value for 
this attribute or the attribute is declared with a default value.
.PP
[... end of excerpt ...]
.SH "CAVEATS"
.IX Header "CAVEATS"
This code is highly experimental! 
It has not been tested well and the \s-1API\s0 may change.
.PP
The code that detects of blocks of whitespace at potential indent positions
may need some work. See
.SH "AUTHOR"
.IX Header "AUTHOR"
Send bug reports, hints, tips, suggestions to Enno Derksen at
<\fIenno@att.com\fR>.
